{"version":3,"file":"index.js","sources":["../src/redux/types/AuthenticationState.ts","../src/redux/types/MinimalExpectedReduxState.ts","../src/redux/hooks/useAuthenticationState.tsx","../src/redux/types/UsersState.ts","../src/redux/types/MinimalExpectedDatabase.ts","../src/redux/hooks/useCurrentUser.tsx","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/redux/thunks/Authentication/signIn.ts","../src/redux/thunks/Authentication/signOut.ts","../src/redux/thunks/Authentication/signUp.ts","../src/redux/thunks/Authentication/subscribeForAuthenticatedUser.ts","../src/redux/thunks/Users/createUser.ts","../src/redux/hooks/useSignIn.tsx","../src/redux/hooks/useSignOut.tsx","../src/redux/hooks/useSignUp.tsx","../src/redux/hooks/useSubscribeForAuthenticatedUser.tsx","../src/redux/thunks/Users/subscribeForUser.ts","../src/redux/hooks/useSubscribeForUser.tsx","../src/redux/thunks/Users/updateUser.ts","../src/redux/hooks/useUpdateUser.tsx","../src/redux/hooks/useCreateUser.tsx","../src/redux/slices/createAuthenticationSlice.ts","../src/redux/slices/createUsersSlice.ts","../src/Authenticate.tsx","../src/Firebase.tsx"],"sourcesContent":["import * as firebase from 'firebase/app';\n\nexport interface AuthenticationState {\n    firebaseUser: firebase.User | undefined | null;\n    loading: boolean;\n}\n\nexport function isAuthenticationState(value: unknown): value is AuthenticationState {\n    const castedValue = value as AuthenticationState;\n    return castedValue.loading != null;\n}\n","import { AuthenticationState, isAuthenticationState } from './AuthenticationState';\nimport { UsersState } from './UsersState';\nimport { MinimalUserData } from './MinimalUser';\n\nexport type MinimalExpectedReduxState = {\n    authentication: AuthenticationState;\n    users: UsersState<MinimalUserData, unknown>;\n};\n\nexport function isMinimalExpectedReduxState(value: unknown): value is MinimalExpectedReduxState {\n    const castedValue = value as MinimalExpectedReduxState;\n    return castedValue.authentication != null && isAuthenticationState(castedValue.authentication) && castedValue.users != null;\n}\n","import { useSelector } from 'react-redux';\nimport { AuthenticationState } from '../types/AuthenticationState';\nimport { isMinimalExpectedReduxState } from '../types/MinimalExpectedReduxState';\n\nfunction getState(state: unknown): Readonly<AuthenticationState> {\n    if (isMinimalExpectedReduxState(state)) {\n        return state.authentication;\n    } else {\n        throw Error('State does not have the expected shape');\n    }\n}\n\nexport function useAuthenticationState(): Readonly<AuthenticationState> {\n    return useSelector(getState);\n}\n","import { MinimalUser, MinimalUserData } from './MinimalUser';\n\nexport interface UsersState<T extends MinimalUserData, S> {\n    values: Map<string, MinimalUser<T, S>>;\n}\n\nexport function isUsersState<T extends MinimalUserData, S>(value: unknown): value is UsersState<T, S> {\n    const casted = value as UsersState<T, S>;\n    return casted.values != null;\n}\n","import { Database, Collection } from 'firebase-db-manager';\nimport { MinimalUserData } from './MinimalUser';\n\ntype UsersCollection<T extends MinimalUserData, S> = Collection<T, S>;\nexport type MinimalExpectedDatabase<T extends MinimalUserData, S> = Database<{ users: UsersCollection<T, S> }>;\n\nexport function isMinimalExpectedDatabase<T extends MinimalUserData, S>(value: unknown): value is MinimalExpectedDatabase<T, S> {\n    const casted = value as MinimalExpectedDatabase<T, S>;\n    return casted.collections.users != null;\n}\n","import { useSelector } from 'react-redux';\nimport { MinimalUser, MinimalUserData } from '../types/MinimalUser';\nimport { useAuthenticationState } from './useAuthenticationState';\nimport { isMinimalExpectedReduxState, UsersState, isUsersState } from '../types';\n\nfunction getUsers<T extends MinimalUserData, S>(state: unknown): Readonly<UsersState<T, S>> {\n    if (isMinimalExpectedReduxState(state) && isUsersState<T, S>(state.users)) {\n        return state.users;\n    } else {\n        throw Error('State does not have the expected shape');\n    }\n}\n\nexport function useCurrentUser<T extends MinimalUserData, S>(): MinimalUser<T, S> | null | undefined {\n    const authState = useAuthenticationState();\n    const users = useSelector(getUsers);\n    if (authState.firebaseUser != null) {\n        return users.values.get(authState.firebaseUser.uid) as MinimalUser<T, S> | null | undefined;\n    } else {\n        return null;\n    }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { createAsyncThunk } from '@reduxjs/toolkit';\nimport * as firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { AuthenticationState } from '../../types/AuthenticationState';\nimport { EmailPasswordPair } from '../../types/EmailPasswordPair';\n\nexport const signIn = createAsyncThunk(\n    'authentication/signIn',\n    async (user: EmailPasswordPair): Promise<AuthenticationState> => {\n        try {\n            const userCredential = await firebase.auth().signInWithEmailAndPassword(user.email, user.password);\n            return {\n                firebaseUser: userCredential.user,\n                loading: false\n            };\n        } catch (error) {\n            alert(error);\n            throw error;\n        }\n    }\n);\n","import { createAsyncThunk } from '@reduxjs/toolkit';\nimport * as firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { AuthenticationState } from '../../types/AuthenticationState';\n\nexport const signOut = createAsyncThunk(\n    'authentication/signOut',\n    async (): Promise<AuthenticationState> => {\n        await firebase.auth().signOut();\n        return {\n            firebaseUser: undefined,\n            loading: false\n        };\n    }\n);\n","import { createAsyncThunk } from '@reduxjs/toolkit';\nimport * as firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { AuthenticationState } from '../../types/AuthenticationState';\nimport { EmailPasswordPair } from '../../types/EmailPasswordPair';\n\nexport const signUp = createAsyncThunk(\n    'authentication/signUp',\n    async (user: EmailPasswordPair): Promise<AuthenticationState> => {\n        try {\n            const userCredential = await firebase.auth().createUserWithEmailAndPassword(user.email, user.password);\n            return {\n                firebaseUser: userCredential.user,\n                loading: false\n            };\n        } catch (error) {\n            alert(error);\n            throw error;\n        }\n    }\n);\n","import * as firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { ThunkDispatch } from 'redux-thunk';\nimport { Action } from 'redux';\nimport { MinimalExpectedReduxState } from '../..';\nimport { authenticationSlice } from '../../slices';\n\nexport const subscribeForAuthenticatedUser = (slice: typeof authenticationSlice) => (\n    dispatch: ThunkDispatch<firebase.Unsubscribe, MinimalExpectedReduxState, Action>\n): firebase.Unsubscribe => {\n    return firebase.auth().onAuthStateChanged(\n        (user) => {\n            dispatch(\n                slice.actions.setAuthenticationState({\n                    firebaseUser: user,\n                    loading: false\n                })\n            );\n        },\n        (error) => {\n            alert(error.message);\n        }\n    );\n};\n","import { ThunkDispatch } from 'redux-thunk';\nimport { Action } from 'redux';\nimport { MinimalExpectedReduxState } from '../..';\nimport { MinimalExpectedDatabase } from '../../types/MinimalExpectedDatabase';\nimport { MinimalUserData } from '../../types';\nimport { UsersSlice } from '../../slices';\n\nexport function createUser<T extends MinimalUserData, S>(database: MinimalExpectedDatabase<T, S>, data: T, usersSlice: UsersSlice) {\n    return async (dispatch: ThunkDispatch<Promise<void>, MinimalExpectedReduxState, Action>): Promise<void> => {\n        const userDocument = await database.collections.users.createDocument(data);\n        dispatch(usersSlice.actions.setUser(userDocument));\n    };\n}\n","import { useDispatch } from 'react-redux';\nimport { signIn } from '../thunks';\nimport { useCallback } from 'react';\n\nexport function useSignIn(email: string, password: string): () => Promise<void> {\n    const dispatch = useDispatch();\n    return useCallback(async () => {\n        await dispatch(\n            signIn({\n                email,\n                password\n            })\n        );\n    }, [email, password, dispatch]);\n}\n","import { useDispatch } from 'react-redux';\nimport { signOut } from '../thunks';\nimport { useCallback } from 'react';\n\nexport function useSignOut(): () => Promise<void> {\n    const dispatch = useDispatch();\n    return useCallback(async () => {\n        await dispatch(signOut());\n    }, [dispatch]);\n}\n","import { useDispatch } from 'react-redux';\nimport { signUp } from '../thunks';\nimport { useCallback } from 'react';\n\nexport function useSignUp(email: string, password: string): () => Promise<void> {\n    const dispatch = useDispatch();\n    return useCallback(async () => {\n        await dispatch(\n            signUp({\n                email,\n                password\n            })\n        );\n    }, [email, password, dispatch]);\n}\n","import { useDispatch } from 'react-redux';\nimport { subscribeForAuthenticatedUser } from '../thunks';\nimport { MinimalExpectedReduxState } from '../types/MinimalExpectedReduxState';\nimport { ThunkDispatch } from 'redux-thunk';\nimport { Action } from 'redux';\nimport { useCallback } from 'react';\nimport { authenticationSlice } from '../slices';\n\nexport function useSubscribeForAuthenticatedUser(slice: typeof authenticationSlice): () => firebase.Unsubscribe {\n    const dispatch = useDispatch<ThunkDispatch<firebase.Unsubscribe, MinimalExpectedReduxState, Action>>();\n    return useCallback(() => {\n        return dispatch(subscribeForAuthenticatedUser(slice));\n    }, [dispatch, slice]);\n}\n","import firebase from 'firebase/app';\nimport { ThunkDispatch } from 'redux-thunk';\nimport { Action } from 'redux';\nimport { MinimalExpectedReduxState } from '../..';\nimport { MinimalExpectedDatabase } from '../../types/MinimalExpectedDatabase';\nimport { MinimalUserData } from '../../types';\nimport { UsersSlice } from '../../slices';\n\nexport function subscribeForUser<T extends MinimalUserData, S>(\n    database: MinimalExpectedDatabase<T, S>,\n    id: string,\n    usersSlice: UsersSlice,\n    onFetchDone?: () => void\n) {\n    return (dispatch: ThunkDispatch<Promise<void>, MinimalExpectedReduxState, Action>): firebase.Unsubscribe => {\n        return database.collections.users.subscribeToDocument(\n            id,\n            (newDocument) => {\n                dispatch(usersSlice.actions.setUser(newDocument));\n                if (onFetchDone) {\n                    onFetchDone();\n                }\n            },\n            (error) => {\n                alert(error.message);\n            },\n            () => {\n                if (onFetchDone) {\n                    onFetchDone();\n                }\n            }\n        );\n    };\n}\n","import { useDispatch } from 'react-redux';\nimport { MinimalExpectedReduxState } from '../types/MinimalExpectedReduxState';\nimport { ThunkDispatch } from 'redux-thunk';\nimport { Action } from 'redux';\nimport { useCallback } from 'react';\nimport { subscribeForUser } from '../thunks/Users/subscribeForUser';\nimport { MinimalExpectedDatabase } from '../types/MinimalExpectedDatabase';\nimport { UsersSlice } from '../slices/createUsersSlice';\nimport { MinimalUserData } from '../types/MinimalUser';\n\nexport function useSubscribeForUser<T extends MinimalUserData, S>(\n    database: MinimalExpectedDatabase<T, S>,\n    id: string,\n    usersSlice: UsersSlice,\n    onFetchDone?: () => void\n): () => firebase.Unsubscribe {\n    const dispatch = useDispatch<ThunkDispatch<firebase.Unsubscribe, MinimalExpectedReduxState, Action>>();\n    return useCallback(() => {\n        return dispatch(subscribeForUser(database, id, usersSlice, onFetchDone));\n    }, [dispatch, database, id, usersSlice, onFetchDone]);\n}\n","import { ThunkDispatch } from 'redux-thunk';\nimport { Action } from 'redux';\nimport { MinimalExpectedReduxState } from '../..';\nimport { MinimalExpectedDatabase } from '../../types/MinimalExpectedDatabase';\nimport { MinimalUserData } from '../../types';\nimport { UsersSlice } from '../../slices';\n\nexport function updateUser<T extends MinimalUserData, S>(database: MinimalExpectedDatabase<T, S>, data: T, usersSlice: UsersSlice) {\n    return async (dispatch: ThunkDispatch<Promise<void>, MinimalExpectedReduxState, Action>): Promise<void> => {\n        const userDocument = await database.collections.users.updateDocument(data);\n        dispatch(usersSlice.actions.setUser(userDocument));\n    };\n}\n","import { useDispatch } from 'react-redux';\nimport { MinimalExpectedReduxState } from '../types/MinimalExpectedReduxState';\nimport { ThunkDispatch } from 'redux-thunk';\nimport { Action } from 'redux';\nimport { useCallback } from 'react';\nimport { UsersSlice } from '../slices/createUsersSlice';\nimport { MinimalUserData } from '../types/MinimalUser';\nimport { MinimalExpectedDatabase } from '../types/MinimalExpectedDatabase';\nimport { updateUser } from '../thunks/Users/updateUser';\n\nexport function useUpdateUser<T extends MinimalUserData, S>(\n    database: MinimalExpectedDatabase<T, S>,\n    usersSlice: UsersSlice\n): (data: T) => Promise<void> {\n    const dispatch = useDispatch<ThunkDispatch<Promise<void>, MinimalExpectedReduxState, Action>>();\n    return useCallback(\n        (data: T) => {\n            return dispatch(updateUser(database, data, usersSlice));\n        },\n        [dispatch, database, usersSlice]\n    );\n}\n","import { useDispatch } from 'react-redux';\nimport { createUser } from '../thunks';\nimport { MinimalExpectedReduxState } from '../types/MinimalExpectedReduxState';\nimport { ThunkDispatch } from 'redux-thunk';\nimport { Action } from 'redux';\nimport { useCallback } from 'react';\nimport { UsersSlice } from '../slices/createUsersSlice';\nimport { MinimalUserData } from '../types/MinimalUser';\nimport { MinimalExpectedDatabase } from '../types/MinimalExpectedDatabase';\n\nexport function useCreateUser<T extends MinimalUserData, S>(\n    database: MinimalExpectedDatabase<T, S>,\n    data: T,\n    usersSlice: UsersSlice\n): () => Promise<void> {\n    const dispatch = useDispatch<ThunkDispatch<Promise<void>, MinimalExpectedReduxState, Action>>();\n    return useCallback(() => {\n        return dispatch(createUser(database, data, usersSlice));\n    }, [dispatch, database, data, usersSlice]);\n}\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthenticationState } from '../types/AuthenticationState';\nimport { signIn } from '../thunks/Authentication/signIn';\nimport { signOut } from '../thunks/Authentication/signOut';\nimport { signUp } from '../thunks/Authentication/signUp';\nimport * as firebase from 'firebase/app';\n\nconst initialState: Readonly<AuthenticationState> = Object.freeze({\n    firebaseUser: undefined,\n    loading: true\n});\n\nfunction replaceAuthenticationState(state: AuthenticationState, action: PayloadAction<AuthenticationState>): void {\n    state.loading = action.payload.loading;\n    state.firebaseUser = action.payload.firebaseUser;\n}\n\nexport const authenticationSlice = createSlice({\n    name: 'authentication',\n    initialState,\n    reducers: {\n        setFirebaseUser: (state, action: PayloadAction<firebase.User | null | undefined>): void => {\n            state.firebaseUser = action.payload;\n        },\n        setLoadingFirebaseData: (state, action: PayloadAction<boolean>): void => {\n            state.loading = action.payload;\n        },\n        setAuthenticationState: replaceAuthenticationState\n    },\n    extraReducers: (builder) => {\n        builder.addCase(signIn.fulfilled, replaceAuthenticationState);\n        builder.addCase(signOut.fulfilled, replaceAuthenticationState);\n        builder.addCase(signUp.fulfilled, replaceAuthenticationState);\n    }\n});\n","import { createSlice, PayloadAction, Slice } from '@reduxjs/toolkit';\nimport { UsersState } from '../types/UsersState';\nimport { MinimalUserData, MinimalUser } from '../types/MinimalUser';\n\ntype UsersMinimalState = UsersState<MinimalUserData, unknown>;\n\nconst initialState: Readonly<UsersMinimalState> = Object.freeze({\n    values: new Map()\n});\n\nexport function createUsersSlice<T extends MinimalUserData, S>(): Slice<\n    Readonly<UsersMinimalState>,\n    {\n        setUser: (state: UsersMinimalState, action: PayloadAction<MinimalUser<T, S>>) => void;\n    },\n    'users'\n> {\n    return createSlice({\n        name: 'users',\n        initialState,\n        reducers: {\n            setUser: (state, action: PayloadAction<MinimalUser<T, S>>): void => {\n                state.values.set(action.payload.id(), action.payload);\n            }\n        }\n    });\n}\n\nexport type UsersSlice = ReturnType<typeof createUsersSlice>;\n","import { useAuthenticationState } from './redux/hooks/useAuthenticationState';\nimport { useCurrentUser } from './redux/hooks/useCurrentUser';\nimport { MinimalUserData, UsersSlice, useSubscribeForAuthenticatedUser, useSubscribeForUser, authenticationSlice } from './redux';\nimport { useEffect, useState, useCallback } from 'react';\nimport { MinimalExpectedDatabase } from './redux/types/MinimalExpectedDatabase';\n\ninterface Props {\n    database: MinimalExpectedDatabase<MinimalUserData, null>;\n    authenticationSlice: typeof authenticationSlice;\n    usersSlice: UsersSlice;\n    loadingComponent: JSX.Element;\n    authenticationComponent: JSX.Element;\n    userNotAvailableComponent: JSX.Element;\n    children: JSX.Element;\n}\n\nexport function Authenticate(props: Props): JSX.Element {\n    const authenticationState = useAuthenticationState();\n    const currentUser = useCurrentUser();\n    const [listeningForUser, setListeningForUser] = useState(false);\n    const { database, authenticationSlice, usersSlice } = props;\n    const subscribeForAuthenticatedUser = useSubscribeForAuthenticatedUser(authenticationSlice);\n    const onFetch = useCallback(() => {\n        setListeningForUser(true);\n    }, []);\n    const subscribeForUser = useSubscribeForUser(database, authenticationState.firebaseUser?.uid ?? '', usersSlice, onFetch);\n\n    useEffect(() => {\n        const unsubscribe = subscribeForAuthenticatedUser();\n        return (): void => {\n            unsubscribe(); // Remove auth listening when the component is unmounted.\n        };\n    }, [subscribeForAuthenticatedUser]);\n\n    useEffect(() => {\n        let unsubscribe: firebase.Unsubscribe | undefined;\n        if (authenticationState.firebaseUser != null) {\n            unsubscribe = subscribeForUser();\n        }\n        return (): void => {\n            if (unsubscribe) {\n                unsubscribe();\n            }\n        };\n    }, [subscribeForUser, authenticationState]);\n\n    if (authenticationState.firebaseUser === undefined && authenticationState.loading) {\n        return props.loadingComponent;\n    } else if (authenticationState.firebaseUser === null && authenticationState.loading === false) {\n        return props.authenticationComponent;\n    } else {\n        if (listeningForUser) {\n            if (currentUser == null) {\n                return props.userNotAvailableComponent;\n            } else {\n                return props.children;\n            }\n        }\n        return props.loadingComponent;\n    }\n}\n","import * as firebase from 'firebase/app';\nimport { useState, useEffect } from 'react';\n\ninterface Config {\n    [key: string]: string;\n}\n\ninterface Props {\n    children: JSX.Element;\n    firebaseConfig: Config;\n    loadingComponent: JSX.Element;\n}\n\nexport function Firebase(props: Props): JSX.Element {\n    const [firebaseReady, setFirebaseReady] = useState(false);\n    const { firebaseConfig } = props;\n\n    useEffect(() => {\n        firebase.initializeApp(firebaseConfig);\n        setFirebaseReady(true);\n    }, [firebaseConfig]);\n\n    return firebaseReady ? props.children : props.loadingComponent;\n}\n"],"names":["isAuthenticationState","value","castedValue","loading","isMinimalExpectedReduxState","authentication","users","getState","state","Error","useAuthenticationState","useSelector","isUsersState","casted","values","isMinimalExpectedDatabase","collections","getUsers","useCurrentUser","authState","firebaseUser","get","uid","signIn","createAsyncThunk","user","firebase","signInWithEmailAndPassword","email","password","userCredential","error","alert","signOut","undefined","signUp","createUserWithEmailAndPassword","subscribeForAuthenticatedUser","slice","dispatch","onAuthStateChanged","actions","setAuthenticationState","message","createUser","database","data","usersSlice","createDocument","userDocument","setUser","useSignIn","useDispatch","useCallback","useSignOut","useSignUp","useSubscribeForAuthenticatedUser","subscribeForUser","id","onFetchDone","subscribeToDocument","newDocument","useSubscribeForUser","updateUser","updateDocument","useUpdateUser","useCreateUser","initialState","Object","freeze","replaceAuthenticationState","action","payload","authenticationSlice","createSlice","name","reducers","setFirebaseUser","setLoadingFirebaseData","extraReducers","builder","addCase","fulfilled","Map","createUsersSlice","set","Authenticate","props","authenticationState","currentUser","useState","listeningForUser","setListeningForUser","onFetch","useEffect","unsubscribe","loadingComponent","authenticationComponent","userNotAvailableComponent","children","Firebase","firebaseReady","setFirebaseReady","firebaseConfig"],"mappings":"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"}